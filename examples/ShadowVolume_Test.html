<!DOCTYPE html>
<html>
	<head>
        <title>Volume Shadow</title>
		<meta charset=utf-8>
        <link rel="shortcut icon" href="Rakete.ico" type="x-icon">
        <link rel="icon" href="Rakete.ico" type="image/x-icon">
	</head>
	<body>
        <script src="three.js/build/three_64.js"></script>
        <script src="three.js/examples/js/libs/stats.min.js"></script>
        <script src="three.js/examples/js/controls/OrbitControls.js"></script>
        
        
        <!-- SHADOW VOLUME Vertex Shader -->
        <script id="shadowVolume_vs" type="x-shader/x-vertex">
            const vec3 lightpos = vec3 (0.0, 7.0, 0.0);   // in world coords
            
#include <common>
#include <logdepthbuf_pars_vertex>

            void main()	{
                
                vec3 normalVec = normalize(normalMatrix * normal);
                vec3 vColor = color;
                
                vec3 lightvec = vec3( viewMatrix * vec4(lightpos, 1.0) );
                vec3 posvec   = vec3( modelViewMatrix * vec4(position, 1.0) );
                vec3 extrudeVec_ = normalize( posvec - lightvec );
                
                if(dot(extrudeVec_, normalVec) < 0.0 && vColor[0] != 0.0) {
                    gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0) + 
                                            vec4 (extrudeVec_, 0.0) * 1000.0);
                }else{
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
                
#ifdef USE_LOGDEPTHBUF
               gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
  #ifdef USE_LOGDEPTHBUF_EXT
               vFragDepth = 1.0 + gl_Position.w;
  #else
               gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
  #endif
#endif
            }
		</script>
        
        
        <!-- SHADOW VOLUME Fragment Shader -->        
        <script id="shadowVolume_fs" type="x-shader/x-fragment">
            
#include <logdepthbuf_pars_fragment>

			void main( void ) {
#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			}
		</script>
        
        
        
        
        <!-- DIFF/SPEC Space Objects Vertex Shader -->  
        <script id="diffSpec_spaceObj_vs" type="x-shader/x-vertex">
        //spaceObject_vertexShader_diffuse_specular
            varying vec3 normal_;
            varying vec3 view_;
        
#include <common>
#include <logdepthbuf_pars_vertex>		
            void main()	{
                            
                normal_ = normalize(normalMatrix * normal);
                view_ = normalize(-vec3(modelViewMatrix * vec4(position, 1.0)));
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                
#ifdef USE_LOGDEPTHBUF
               gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
  #ifdef USE_LOGDEPTHBUF_EXT
               vFragDepth = 1.0 + gl_Position.w;
  #else
               gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
  #endif
#endif
			}
		</script>
        
        <!-- DIFF/SPEC Space Objects Fragment Shader -->  
        <script id="diffSpec_spaceObj_fs" type="x-shader/x-fragment">
        //spaceObject_fragmentShader_diffuse_specular
            uniform vec3 l;
            
            varying vec3 normal_;
            varying vec3 view_;
            
#include <logdepthbuf_pars_fragment>

			void main( void ) {
#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
            
                vec3 n = normalize(normal_);
                vec3 v = normalize(view_);
                vec3 halfway = normalize(v + l);
                                    
                float Id = max(dot( l, n), 0.0);
                float Is = pow(max(dot(halfway, n), 0.0), 32.0);
                
                vec3 col = Id * vec3(0.5, 0.5, 0.5) + Is * vec3(0.3, 0.3, 0.3);
                gl_FragColor = vec4(col, 1.0);
			    //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
		</script>
        
        
        
        
        <!-- AMBIENT Space Objects Vertex Shader -->  
        <script id="ambient_spaceObj_vs" type="x-shader/x-vertex">
        //spaceObject_vertexShader_ambient

#include <common>
#include <logdepthbuf_pars_vertex>

			void main()	{   
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                
#ifdef USE_LOGDEPTHBUF
               gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
  #ifdef USE_LOGDEPTHBUF_EXT
               vFragDepth = 1.0 + gl_Position.w;
  #else
               gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
  #endif
#endif
			}
		</script>
        
        <!-- AMBIENT Space Objects Fragment Shader -->  
        <script id="ambient_spaceObj_fs" type="x-shader/x-fragment">
        //spaceObject_fragmentShader_ambient
#include <logdepthbuf_pars_fragment>

			void main( void ) {
#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			}
		</script>
        
        
        
        
                <!-- DIFF/SPEC Space Objects Vertex Shader -->  
        <script id="diffSpec_earth_vs" type="x-shader/x-vertex">
        //earth_vertexShader_diffuse_specular
            varying vec3 normal_;
            varying vec3 view_;
        
#include <common>
#include <logdepthbuf_pars_vertex>		
            void main()	{
                            
                normal_ = normalize(normalMatrix * normal);
                view_ = normalize(-vec3(modelViewMatrix * vec4(position, 1.0)));
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                
#ifdef USE_LOGDEPTHBUF
               gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
  #ifdef USE_LOGDEPTHBUF_EXT
               vFragDepth = 1.0 + gl_Position.w;
  #else
               gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
  #endif
#endif
			}
		</script>
        
        <!-- DIFF/SPEC Space Objects Fragment Shader -->  
        <script id="diffSpec_earth_fs" type="x-shader/x-fragment">
        //earth_fragmentShader_diffuse_specular
            uniform vec3 l;
            
            varying vec3 normal_;
            varying vec3 view_;
            
#include <logdepthbuf_pars_fragment>

			void main( void ) {
#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif
            
                vec3 n = normalize(normal_);
                vec3 v = normalize(view_);
                vec3 halfway = normalize(v + l);
                                    
                float Id = max(dot( l, n), 0.0);
                float Is = pow(max(dot(halfway, n), 0.0), 32.0);
                
                vec3 col = Id * vec3(0.5, 0.5, 0.5) + Is * vec3(0.3, 0.3, 0.3);
                gl_FragColor = vec4(col, 1.0);
			    //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
		</script>
        
        
        <!-- AMBIENT Earth Vertex Shader -->  
        <script id="ambient_earth_vs" type="x-shader/x-vertex">
        //earth_vertexShader_ambient

        varying vec2 vUv;
#include <common>
#include <logdepthbuf_pars_vertex>

			void main()	{ 
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                
#ifdef USE_LOGDEPTHBUF
               gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
  #ifdef USE_LOGDEPTHBUF_EXT
               vFragDepth = 1.0 + gl_Position.w;
  #else
               gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
  #endif
#endif
			}
		</script>
        
        <!-- AMBIENT Earth Fragment Shader -->  
        <script id="ambient_earth_fs" type="x-shader/x-fragment">
        //earth_fragmentShader_ambient
            uniform sampler2D texture;
            varying vec2 vUv;
        
        
#include <logdepthbuf_pars_fragment>

			void main( void ) {
#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif

                vec3 texCol = texture2D( texture, vUv ).rgb;
                
                gl_FragColor = vec4(texCol, 1.0);
			}
		</script>
        
    
        
        <!-- Own Shaders for coloring the spheres -->
        
        
        <!-- Space Object Vertex Shader -->
        <script id="spaceObj_vs" type="x-shader/x-vertex">
        //spaceObject_vertexShader
            varying vec2 vUv;
            varying vec3 normal_;
            varying vec3 view_;
            varying vec3 light;

#include <common>
#include <logdepthbuf_pars_vertex>

			void main()	{
                vUv = uv;
                normal_ = normalize(normalMatrix * normal);
                view_ = -vec3(modelViewMatrix * vec4(position, 1.0));
                light = vec3 (viewMatrix * vec4 (0.0, 7.0, 0.0, 1.0)) + view_;  // licht in weltkoord -> light vector in augenkoord
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                
#ifdef USE_LOGDEPTHBUF
               gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
  #ifdef USE_LOGDEPTHBUF_EXT
               vFragDepth = 1.0 + gl_Position.w;
  #else
               gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
  #endif
#endif
			}
		</script>
        
         
        <!-- Space Object Fragment Shader -->        
        <script id="spaceObj_fs" type="x-shader/x-fragment">
        //spaceObject_fragmentShader
            uniform sampler2D texture;
            //uniform sampler2D bumpTexture;
            
            varying vec2 vUv;
            //uniform vec3 l;
            varying vec3 normal_;
            varying vec3 view_;
            varying vec3 light;
            
#include <logdepthbuf_pars_fragment>

			void main( void ) {
#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)
        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;
#endif     
                vec3 texCol = texture2D( texture, vUv ).rgb;
            
                vec3 l = normalize (light);
           
                vec3 n = normalize(normal_);
                vec3 v = normalize(view_);
                vec3 halfway = normalize(v + l);
                

                float Id = max(dot(l, n), 0.0);
                float Is = pow(max(dot(halfway, n), 0.0), 32.0);
                
                vec3 col =  vec3(0.0, 0.0, 0.1) +              //Ia * vec3(texCol) + 
                            Id * texCol + 
                            Is * vec3(0.3, 0.3, 0.3);
        
                gl_FragColor = vec4(col, 1.0);
			    //gl_FragColor = vec4(100.0*vUv.x+.5, 100.0*vUv.y+.5, 0.0, 1.0);
            }
                
		</script>
          
        
        <!-- THREE.js Script starts here -->
		<script>
            var stats, camera, renderer, material_diffuse_specular, material_volume, material_ambient;
            
            var scene,     mesh_torus,    mesh_ground,    mesh_moon,    mesh_earth,    mesh_sun;
            var sceneVol,  meshVol_torus, meshVol_ground, meshVol_moon, meshVol_earth, meshVol_sun;
            
            var uniforms1, uniforms2;
            var loader = new THREE.TextureLoader();    
            
            
            init();
			animate();
            
            function init() {
                renderer = new THREE.WebGLRenderer({
                    logarithmicDepthBuffer: true,
                    //alpha: true,
                    antialisa: true
                });
                
                renderer.autoClear = false;
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                
                scene = new THREE.Scene();
                sceneVol = new THREE.Scene();
                
                //axisHelper
                var axisHelper = new THREE.AxisHelper(100); //
                scene.add(axisHelper);
                
                
                var imagePrefix = "textures/stars_for_skybox1/";
                var directions = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
                var imageSuffix = ".png";
        
                var materialArray = [];
                for (var i = 0; i < 6; i++)
                    materialArray.push(new THREE.MeshBasicMaterial({
                        map: loader.load(imagePrefix + directions[i] + imageSuffix),
                        side: THREE.BackSide
                    }));
        
                var skyGeometry = new THREE.CubeGeometry(1e17, 1e17, 1e17); //26
                var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
                var skyBox = new THREE.Mesh(skyGeometry, skyMaterial);
                scene.add(skyBox);
                
                   
                var lightVec = new THREE.Vector3( -1, -1, -1);         
                var light = new THREE.Vector3().copy(lightVec).negate().normalize();
                
                
                //PointLight
                /*var pointLight = new THREE.PointLight(lightVec);
                geo_light = new THREE.SphereGeometry(0.5, 64, 64);
                mat_light = new THREE.MeshBasicMaterial();
                mesh_light = new THREE.Mesh(geo_light, mat_light);
                
                pointLight.add( mesh_light );
                scene.add( pointLight );*/
                
                
                /*      ---   Create all volume geometries for the objects   ---     */
                //Torus
                var object_vol_geometry = new THREE.TorusKnotGeometry(2, 0.5, 100, 16);
                var object_vol_geometry_faceNum = object_vol_geometry.faces.length;
                
                //Ground Plate
                var ground_vol_geometry = new THREE.BoxGeometry(75, 0.1, 75);
                var ground_vol_geometry_faceNum = ground_vol_geometry.faces.length;
                
                //Moon
                var moon_geo_vol = new THREE.SphereGeometry(1, 64, 64);
                var moon_geo_faceNum = moon_geo_vol.faces.length;
                
                //Earth
                var sphere_earth_geo_vol = new THREE.SphereGeometry(3, 128, 128);
                var sphere_earth_faceNum = sphere_earth_geo_vol.faces.length;
                
                //Sun
                var sun_geo = new THREE.SphereGeometry(1, 64, 64);
                var sun_faceNum = sun_geo.faces.length;
                
                
                /*      ---   Create all arrays to iterate over faceNums and shadow volume geometries   ---     */
                //Arrays
                var faceNumArray = { object_vol_geometry_faceNum, ground_vol_geometry_faceNum, moon_geo_faceNum, sphere_earth_faceNum, sun_faceNum};
                var volGeoArray =  { object_vol_geometry,         ground_vol_geometry,         moon_geo_vol,     sphere_earth_geo_vol,     sun_geo};
                
                
                var color1 = [new THREE.Color(0x00ffff), new THREE.Color(0xff0000), new THREE.Color(0xff0000)];
                var color2 = [new THREE.Color(0x00ffff), new THREE.Color(0x00ffff), new THREE.Color(0xff0000)];
                
                
                for (var j = 0; j<faceNumArray.length; j++){
                    
                    for (var i = 0; i < faceNumArray[j]; i++) {
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].a,          //vertex-position
                                                                    volGeoArray[j].faces[i].b,          //vertex-position
                                                                    volGeoArray[j].faces[i].a,          //vertex-position
                                                                    volGeoArray[j].faces[i].normal,     //orientation -> light
                                                                    color2));                           //tagging-attribute for vertices
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color1));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].normal,
                                                                       color2));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color1));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color2));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color1));
                        
                        
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                    
                    }
                }
                
                
                /*      ---   Create the meshes, set the position, add shadow volume and object to the scenes ---     */
                //TORUS
                meshVol_torus = new THREE.Mesh(object_vol_geometry);
                meshVol_torus.position.set(0, 0, -5);
                sceneVol.add(meshVol_torus);
                
                mesh_torus = new THREE.Mesh(new THREE.TorusKnotGeometry(2, 0.5, 100, 16));
                mesh_torus.position.set(0, 0, -5);
                scene.add(mesh_torus);
                
                
                //GROUND-PLATE
                meshVol_ground = new THREE.Mesh(ground_vol_geometry);
                meshVol_ground.position.set(0, -25, 0);
                sceneVol.add(meshVol_ground);
                
                mesh_ground = new THREE.Mesh(new THREE.BoxGeometry(75, 0.1, 75));
                mesh_ground.position.set(0, -25, 0);
                scene.add(mesh_ground);
                
                
                //MOON
                meshVol_moon = new THREE.Mesh(moon_geo_vol);
                meshVol_moon.position.set(0, 2, 5);
                sceneVol.add(meshVol_moon);
                
                
                uniforms1 = {
                    texture: { value: loader.load( "textures/moon/moon_map.jpg" ) }
                };
                
                moon_mat = new THREE.ShaderMaterial( {
						uniforms: uniforms1,
						vertexShader: document.getElementById( 'spaceObj_vs' ).textContent,
						fragmentShader: document.getElementById( 'spaceObj_fs' ).textContent
				    } );
                
                mesh_moon = new THREE.Mesh(moon_geo_vol, moon_mat);
                mesh_moon.position.set(0, 2, 5);
                scene.add(mesh_moon);
                
                
                //EARTH
                meshVol_earth = new THREE.Mesh(sphere_earth_geo_vol);
                meshVol_earth.position.set(0, 0, 10);
                sceneVol.add(meshVol_earth);
                
                uniforms2 = {
                    texture: { value: loader.load( "textures/earth/earth_map.jpg" ) }
                };   
                
                sphere_mat_earth = new THREE.ShaderMaterial( {
						uniforms: uniforms2,
						vertexShader: document.getElementById( 'spaceObj_vs' ).textContent,
						fragmentShader: document.getElementById( 'spaceObj_fs' ).textContent
				    } );
                
                mesh_earth = new THREE.Mesh(sphere_earth_geo_vol, sphere_mat_earth);
                mesh_earth.position.set(0, 0, 10);
                scene.add(mesh_earth);

                
                //Sun
                meshVol_sun = new THREE.Mesh(sun_geo);
                meshVol_sun.position.set(0, 7, 0);
                sceneVol.add(meshVol_sun);
                
                uniforms3 = {
                    texture: { value: loader.load( "textures/sun/sun_map.jpg" ) }
                };   
                
                mat_sun = new THREE.ShaderMaterial( {
						uniforms: uniforms3,
						vertexShader: document.getElementById( 'spaceObj_vs' ).textContent,
						fragmentShader: document.getElementById( 'spaceObj_fs' ).textContent
				    } );
                
                mesh_sun = new THREE.Mesh(sun_geo, mat_sun);
                mesh_sun.position.set(0, 7, 0);
                scene.add(mesh_sun);
                 
                
                //Camera         
                camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1.0, 1e16); //1e27
                camera.position.set(-15, 10, 10);
                
                
                
                //Bounding Box
                var sceneBoundingBox = new THREE.BoundingBoxHelper(scene);
                sceneBoundingBox.update();
                
                var extrude_size = sceneBoundingBox.box.getSize().length();
                var center = sceneBoundingBox.box.getCenter();
                
                /*
                var extrudeVec = new THREE.Vector3();
                extrudeVec.copy(light).negate().multiplyScalar(extrude_size);
                
                var extrudeMat = new THREE.Matrix4();
                extrudeMat.makeTranslation(extrudeVec.x, extrudeVec.y, extrudeVec.z);
                */
                
                /*      ---   Create the shader for the shadow materials for each object   ---     */
                //Shadow Volume Shader for material
                //material_shadowVolume
				shadowVolume_mat = new THREE.ShaderMaterial({
                    vertexShader: document.getElementById('shadowVolume_vs').textContent,
                    vertexColors: THREE.VertexColors,
					fragmentShader: document.getElementById('shadowVolume_fs').textContent
				});
                       
                meshVol_torus.material = shadowVolume_mat;      //Torus
                meshVol_ground.material = shadowVolume_mat;     //Ground Plate
                meshVol_moon.material = shadowVolume_mat;       //Moon
                meshVol_earth.material = shadowVolume_mat;      //Earth
                meshVol_sun.material = shadowVolume_mat;        //Sun
                
                     
                /*      ---   Create the shaders for earth and moon   ---     */ 
                //Moon
                moon_mat_Shader = new THREE.ShaderMaterial({
                    uniforms: uniforms1,
                    vertexShader: document.getElementById('spaceObj_vs').textContent,
					fragmentShader: document.getElementById('spaceObj_fs').textContent
				});
                 
                //Earth
                sphere_earth_Shader = new THREE.ShaderMaterial({
                    uniforms: uniforms2,
                    vertexShader: document.getElementById('spaceObj_vs').textContent,
					fragmentShader: document.getElementById('spaceObj_fs').textContent
				});
                
                //Sun
                sun_Shader = new THREE.ShaderMaterial({
                    uniforms: uniforms3,
                    vertexShader: document.getElementById('spaceObj_vs').textContent,
					fragmentShader: document.getElementById('spaceObj_fs').textContent
				});
        
                
                /*      ---   Create the shaders for lightning   ---     */   
                //DIFF/SPEC Space Objects Shaders
                //material_diffuse_specular
                diffSpec_spaceObj_mat = new THREE.ShaderMaterial({
                    uniforms: { l: {type: "v3", value: light} },
                    vertexShader: document.getElementById('diffSpec_spaceObj_vs').textContent,
					fragmentShader: document.getElementById('diffSpec_spaceObj_fs').textContent
				});
                
                //AMBIENT Shadow VolumeE Shaders
                //material_ambient
                ambient_spaceObj_mat = new THREE.ShaderMaterial({
                    vertexShader: document.getElementById('ambient_spaceObj_vs').textContent,
					fragmentShader: document.getElementById('ambient_spaceObj_fs').textContent
				});
    
                
                
                uniforms4 = {
                    texture: { value: loader.load( "textures/earth/earth_map_lights.jpg" ) }
                }; 
                
                
                
                //AMBIENT EARTH 
                //sphere_mesh_earth_ambient
                ambient_earth_mat = new THREE.ShaderMaterial({
                    uniforms: uniforms4,
                    vertexShader: document.getElementById('ambient_earth_vs').textContent,
					fragmentShader: document.getElementById('ambient_earth_fs').textContent
				});
                
                
                //Controls
                var controls = new THREE.OrbitControls(camera);
                controls.update();
                
                //Stats
                stats = new Stats();
                stats.setMode(0);
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';
                document.body.appendChild(stats.domElement);
			}
            
             
            //Animation
            function animate() {
				requestAnimationFrame(animate);
                //mesh_torus.rotation.y += 0.005;
                render();
                stats.update();
			}
            

            //Rendering
			function render() {
                renderer.clear();
                var gl = renderer.context;
                
                
                //Render all objects ambient material
                mesh_torus.material = ambient_spaceObj_mat;
                mesh_ground.material = ambient_spaceObj_mat;              
                mesh_moon.material = ambient_spaceObj_mat;
                mesh_earth.material = ambient_earth_mat;
                mesh_sun.material = ambient_spaceObj_mat;
                
                
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LESS);
                renderer.render(scene, camera);
                
                gl.colorMask(false, false, false, false);
                gl.depthMask(false);
                gl.enable(gl.STENCIL_TEST);
                gl.disable(gl.CULL_FACE);
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.INCR_WRAP);
                gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.DECR_WRAP);
                gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
                renderer.render(sceneVol, camera);
                
                //Render all objects diff/spec material
                mesh_torus.material = diffSpec_spaceObj_mat;
                mesh_ground.material = diffSpec_spaceObj_mat;
                mesh_moon.material = moon_mat_Shader;         
                mesh_earth.material = sphere_earth_Shader;         
                mesh_sun.material = sun_Shader;
                
                
                gl.colorMask(true, true, true, true);
                gl.depthMask(true);
                gl.enable(gl.CULL_FACE);
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.depthFunc(gl.LEQUAL);
                gl.stencilFunc(gl.EQUAL, 0, 0xFF);
                renderer.render(scene, camera);
                
                mesh_earth.rotateY(0.0025);
                
			}
		</script>  
	</body>
</html>