<!DOCTYPE html>
<html>
	<head>
        <title>Volume Shadow</title>
		<meta charset=utf-8>
        <link rel="shortcut icon" href="Rakete.ico" type="x-icon">
        <link rel="icon" href="Rakete.ico" type="image/x-icon">
	</head>
	<body>
        <script src="three.js/build/three_64.js"></script>
        <script src="three.js/examples/js/libs/stats.min.js"></script>
        <script src="three.js/examples/js/controls/OrbitControls.js"></script>
        
        <script id="vertexShader_shadowVolume" type="x-shader/x-vertex">
            uniform mat4 extrudeMat;
            uniform vec3 l;
        
            void main()	{
                vec3 normalVec = normalize(normalMatrix * normal);
                vec3 vColor = color;
                
                if(dot(l, normalVec) < 0.0) {
                    gl_Position = projectionMatrix * extrudeMat * modelViewMatrix * vec4(position, 1.0);
                    if(vColor[0] == 0.0) {
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                } else {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            }
		</script>
        
        <script id="fragmentShader_shadowVolume" type="x-shader/x-fragment">
			void main()	{
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			}
		</script>
        
        <script id="vertexShader_diffuse_specular" type="x-shader/x-vertex">
            varying vec3 normal_;
            varying vec3 view_;
        
			void main()	{
                normal_ = normalize(normalMatrix * normal);
                view_ = normalize(-vec3(modelViewMatrix * vec4(position, 1.0)));
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
        
        <script id="fragmentShader_diffuse_specular" type="x-shader/x-fragment">
            uniform vec3 l;
            varying vec3 normal_;
            varying vec3 view_;
            
			void main()	{
                vec3 n = normalize(normal_);
                vec3 v = normalize(view_);
                vec3 halfway = normalize(v + l);
                
                float Id = max(dot(l, n), 0.0);
                float Is = pow(max(dot(halfway, n), 0.0), 32.0);
                
                vec3 col = Id * vec3(0.5, 0.5, 0.5) + Is * vec3(0.3, 0.3, 0.3);
                gl_FragColor = vec4(col, 1.0);
			    //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
		</script>
        
        <script id="vertexShader_ambient" type="x-shader/x-vertex">
			void main()	{
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
        
        <script id="fragmentShader_ambient" type="x-shader/x-fragment">
			void main()	{
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			}
		</script>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <script id="sphere_mat_vertexShader" type="x-shader/x-vertex">
        
            varying vec2 vUv;
            varying vec3 normal_;
            varying vec3 view_;
        
			void main()	{
                vUv = uv;
                normal_ = normalize(normalMatrix * normal);
                view_ = normalize(-vec3(modelViewMatrix * vec4(position, 1.0)));
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
        
         
        
        <script id="sphere_mat_fragmentShader" type="x-shader/x-fragment">
        
            uniform sampler2D moon_tex;
            //uniform sampler2D bumpTexture;
            
            varying vec2 vUv;
            uniform vec3 l;
            varying vec3 normal_;
            varying vec3 view_;
            
			void main()	{
            
                vec3 texCol = texture2D( moon_tex, vUv ).rgb;
            
                vec3 n = normalize(normal_);
                vec3 v = normalize(view_);
                vec3 halfway = normalize(v + l);
                
                

                float Ia = max(dot(halfway,n), 0.0);
                float Id = max(dot(l, n), 0.0);
                float Is = pow(max(dot(halfway, n), 0.0), 32.0);
                
                vec3 col =  Ia * vec3(1.0, 0.0, 0.0) +              //Ia * vec3(1.0, 0.0, 0.0) + 
                            Id * vec3(0.5, 0.5, 0.5) + 
                            Is * vec3(0.3, 0.3, 0.3);
                            
                gl_FragColor = vec4(col, 1.0);
			    //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
                
		</script>
        
        
        
        
        
        
        
        <script id="sphere_earth_vertexShader" type="x-shader/x-vertex">
        
            varying vec2 vUv;
            varying vec3 normal_;
            varying vec3 view_;
            varying vec3 light;

#include <common>

			void main()	{
                vUv = uv;
                normal_ = normalize(normalMatrix * normal);
                view_ = -vec3(modelViewMatrix * vec4(position, 1.0));
                light = vec3 (viewMatrix * vec4 (0.0, 0.0, 0.0, 1.0)) + view_;  // licht in weltkoord -> light vector in augenkoord
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
        
        
        <script id="sphere_earth_fragmentShader" type="x-shader/x-fragment">
        
            uniform sampler2D earth_tex;
            //uniform sampler2D bumpTexture;
            
            varying vec2 vUv;
            //uniform vec3 l;
            varying vec3 normal_;
            varying vec3 view_;
            varying vec3 light;
            
			void main()	{
            
                vec3 texCol = texture2D( earth_tex, vUv ).rgb;
            
                vec3 l = normalize (light);
           
                vec3 n = normalize(normal_);
                vec3 v = normalize(view_);
                vec3 halfway = normalize(v + l);
                

                float Id = max(dot(l, n), 0.0);
                float Is = pow(max(dot(halfway, n), 0.0), 32.0);
                
                vec3 col =  vec3(0.0, 0.0, 0.1) +              //Ia * vec3(texCol) + 
                            Id * texCol + 
                            Is * vec3(0.3, 0.3, 0.3);
        
                gl_FragColor = vec4(col, 1.0);
			    //gl_FragColor = vec4(100.0*vUv.x+.5, 100.0*vUv.y+.5, 0.0, 1.0);
            }
            
		</script>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
		<script>
            var stats, camera, renderer, material_diffuse_specular, material_volume, material_ambient;
            
            var scene,     object,     ground,     moon_mesh,     sphere_mesh_earth,     sun_mesh;
            var scene_vol, object_vol, ground_vol, moon_mesh_vol, sphere_mesh_earth_vol, sun_mesh_vol;
            
            var uniforms1, uniforms2;
            var loader = new THREE.TextureLoader();    
            
            
            init();
			animate();
            
            function init() {
                renderer = new THREE.WebGLRenderer({
                    logarithmicDepthBuffer: true,
                    //alpha: true,
                    antialisa: true
                });
                
                renderer.autoClear = false;
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                
                scene = new THREE.Scene();
                scene_vol = new THREE.Scene();
                
                //axisHelper
                var axisHelper = new THREE.AxisHelper(100); //
                scene.add(axisHelper);
                
                
                var imagePrefix = "textures/stars_for_skybox1/";
                var directions = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
                var imageSuffix = ".png";
        
                var materialArray = [];
                for (var i = 0; i < 6; i++)
                    materialArray.push(new THREE.MeshBasicMaterial({
                        map: loader.load(imagePrefix + directions[i] + imageSuffix),
                        side: THREE.BackSide
                    }));
        
                var skyGeometry = new THREE.CubeGeometry(1e17, 1e17, 1e17); //26
                var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
                var skyBox = new THREE.Mesh(skyGeometry, skyMaterial);
                scene.add(skyBox);
                
                   
                var lightVec = new THREE.Vector3( -1, -1, -1);         
                var light = new THREE.Vector3().copy(lightVec).negate().normalize();
                
                
                //PointLight
                /*var pointLight = new THREE.PointLight(lightVec);
                geo_light = new THREE.SphereGeometry(0.5, 64, 64);
                mat_light = new THREE.MeshBasicMaterial();
                mesh_light = new THREE.Mesh(geo_light, mat_light);
                
                pointLight.add( mesh_light );
                scene.add( pointLight );*/
                
                
                /*      ---   Create all volume geometries for the objects   ---     */
                //Torus
                var object_vol_geometry = new THREE.TorusKnotGeometry(2, 0.5, 100, 16);
                var object_vol_geometry_faceNum = object_vol_geometry.faces.length;
                
                //Ground Plate
                var ground_vol_geometry = new THREE.BoxGeometry(75, 0.1, 75);
                var ground_vol_geometry_faceNum = ground_vol_geometry.faces.length;
                
                //Moon
                var moon_geo_vol = new THREE.SphereGeometry(1, 64, 64);
                var moon_geo_faceNum = moon_geo_vol.faces.length;
                
                //Earth
                var sphere_earth_geo_vol = new THREE.SphereGeometry(3, 64, 64);
                var sphere_earth_faceNum = sphere_earth_geo_vol.faces.length;
                
                //Sun
                var sun_geo = new THREE.SphereGeometry(1, 64, 64);
                var sun_faceNum = sun_geo.faces.length;
                
                
                /*      ---   Create all arrays to iterate over faceNums and shadow volume geometries   ---     */
                //Arrays
                var faceNumArray = { object_vol_geometry_faceNum, ground_vol_geometry_faceNum, moon_geo_faceNum, sphere_earth_faceNum, sun_faceNum};
                var volGeoArray =  { object_vol_geometry,         ground_vol_geometry,         moon_geo_vol,     sphere_earth_geo_vol,     sun_geo};
                
                
                var color1 = [new THREE.Color(0x00ffff), new THREE.Color(0xff0000), new THREE.Color(0xff0000)];
                var color2 = [new THREE.Color(0x00ffff), new THREE.Color(0x00ffff), new THREE.Color(0xff0000)];
                
                
                for (var j = 0; j<faceNumArray.length; j++){
                    
                    for (var i = 0; i < faceNumArray[j]; i++) {
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].a,          //vertex-position
                                                                    volGeoArray[j].faces[i].b,          //vertex-position
                                                                    volGeoArray[j].faces[i].a,          //vertex-position
                                                                    volGeoArray[j].faces[i].normal,     //orientation -> light
                                                                    color2));                           //tagging-attribute for vertices
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color1));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].normal,
                                                                       color2));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].b,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color1));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color2));
                        
                        volGeoArray[j].faces.push(new THREE.Face3(  volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].a,
                                                                    volGeoArray[j].faces[i].c,
                                                                    volGeoArray[j].faces[i].normal,
                                                                    color1));
                        
                        
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                        volGeoArray[j].faceVertexUvs[0].push([new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()]);
                    
                    }
                }
                
                
                /*      ---   Create the meshes, set the position, add shadow volume and object to the scenes ---     */
                //TORUS
                object_vol = new THREE.Mesh(object_vol_geometry);
                object_vol.position.set(0, 0, -5);
                scene_vol.add(object_vol);
                
                object = new THREE.Mesh(new THREE.TorusKnotGeometry(2, 0.5, 100, 16));
                object.position.set(0, 0, -5);
                scene.add(object);
                
                
                //GROUND-PLATE
                ground_vol = new THREE.Mesh(ground_vol_geometry);
                ground_vol.position.set(0, -25, 0);
                scene_vol.add(ground_vol);
                
                ground = new THREE.Mesh(new THREE.BoxGeometry(75, 0.1, 75));
                ground.position.set(0, -25, 0);
                scene.add(ground);
                
                
                //MOON
                moon_mesh_vol = new THREE.Mesh(moon_geo_vol);
                moon_mesh_vol.position.set(0, 0, 5);
                scene_vol.add(moon_mesh_vol);
                
                
                uniforms1 = {
                    moon_tex: { value: loader.load( "textures/moon/moon_map.jpg" ) },
                };
                
                moon_mat = new THREE.ShaderMaterial( {
						uniforms: uniforms1,
						vertexShader: document.getElementById( 'sphere_mat_vertexShader' ).textContent,
						fragmentShader: document.getElementById( 'sphere_mat_fragmentShader' ).textContent
				    } );
                
                moon_mesh = new THREE.Mesh(moon_geo_vol, moon_mat);
                moon_mesh.position.set(0, 0, 5);
                scene.add(moon_mesh);
                
                
                //EARTH
                sphere_mesh_earth_vol = new THREE.Mesh(sphere_earth_geo_vol);
                sphere_mesh_earth_vol.position.set(0, 0, 10);
                scene_vol.add(sphere_mesh_earth_vol);
                
                uniforms2 = {
                    earth_tex: { value: loader.load( "textures/earth/earth_map.jpg" ) },
                };   
                
                sphere_mat_earth = new THREE.ShaderMaterial( {
						uniforms: uniforms2,
						vertexShader: document.getElementById( 'sphere_earth_vertexShader' ).textContent,
						fragmentShader: document.getElementById( 'sphere_earth_fragmentShader' ).textContent
				    } );
                
                sphere_mesh_earth = new THREE.Mesh(sphere_earth_geo_vol, sphere_mat_earth);
                sphere_mesh_earth.position.set(0, 0, 10);
                scene.add(sphere_mesh_earth);

                
                //Sun
                var sun_mat = new THREE.MeshBasicMaterial({ color:0xffff00 });
                //global for render()
                sun_mesh = new THREE.Mesh(sun_geo, sun_mat);
                sun_mesh.position.set(0, 0, 0);
                scene.add(sun_mesh);
                
                sun_mesh_vol = new THREE.Mesh(sun_geo);
                sun_mesh_vol.position.set(0, 0, 0);
                scene_vol.add(sun_mesh_vol);
                
                 
                
                //Camera         
                camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1.0, 1e16); //1e27
                camera.position.set(-15, 10, 10);
                
                
                
                //Bounding Box
                var sceneBoundingBox = new THREE.BoundingBoxHelper(scene);
                sceneBoundingBox.update();
                
                var extrude_size = sceneBoundingBox.box.getSize().length();
                var center = sceneBoundingBox.box.getCenter();
                
                var extrudeVec = new THREE.Vector3();
                extrudeVec.copy(light).negate().multiplyScalar(extrude_size);
                
                var extrudeMat = new THREE.Matrix4();
                extrudeMat.makeTranslation(extrudeVec.x, extrudeVec.y, extrudeVec.z);
                
                
                /*      ---   Create the shader for the shadow materials for each object   ---     */
                //Shadow Volume Shader for material
				material_shadowVolume = new THREE.ShaderMaterial({
                    uniforms: {extrudeMat: {type: "m4", value: extrudeMat}, l: {type: "v3", value: light}},
                    vertexShader: document.getElementById('vertexShader_shadowVolume').textContent,
                    vertexColors: THREE.VertexColors,
					fragmentShader: document.getElementById('fragmentShader_shadowVolume').textContent
				});
                       
                object_vol.material = material_shadowVolume;                //Torus
                ground_vol.material = material_shadowVolume;                //Ground Plate
                moon_mesh_vol.material = material_shadowVolume;             //Moon
                sphere_mesh_earth_vol.material = material_shadowVolume;     //Earth
                sun_mesh_vol.material = material_shadowVolume;              //Sun
                
                     
                /*      ---   Create the shaders for earth and moon   ---     */        
                //Switch on shader for earth
                sphere_earth_Shader = new THREE.ShaderMaterial({
                    uniforms: uniforms2,
                    vertexShader: document.getElementById('sphere_earth_vertexShader').textContent,
					fragmentShader: document.getElementById('sphere_earth_fragmentShader').textContent
				});
                
                //Switch on shader for moon
                moon_mat_Shader = new THREE.ShaderMaterial({
                    vertexShader: document.getElementById('sphere_mat_vertexShader').textContent,
					fragmentShader: document.getElementById('sphere_mat_fragmentShader').textContent
				});
                
                
                /*      ---   Create the shaders for lightning   ---     */   
                //Shadow Volume Shader for diff & spec
                material_diffuse_specular = new THREE.ShaderMaterial({
                    uniforms: {l: {type: "v3", value: light}},
                    vertexShader: document.getElementById('vertexShader_diffuse_specular').textContent,
					fragmentShader: document.getElementById('fragmentShader_diffuse_specular').textContent
				});
                
                //Shadow Volume Shader for ambient
                material_ambient = new THREE.ShaderMaterial({
                    vertexShader: document.getElementById('vertexShader_ambient').textContent,
					fragmentShader: document.getElementById('fragmentShader_ambient').textContent
				});
                
                
                //Controls
                var controls = new THREE.OrbitControls(camera);
                controls.update();
                
                //Stats
                stats = new Stats();
                stats.setMode(0);
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';
                document.body.appendChild(stats.domElement);
			}
            
             
            //Animation
            function animate() {
				requestAnimationFrame(animate);
                //object.rotation.y += 0.005;
                render();
                stats.update();
			}
            

            //Rendering
			function render() {
                renderer.clear();
                var gl = renderer.context;
                
                
                //Render all objects ambient material
                object.material = material_ambient;
                ground.material = material_ambient;              
                moon_mesh.material = material_ambient;
                sphere_mesh_earth.material = material_ambient;
                sun_mesh.material = material_ambient;
                
                
                
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LESS);
                renderer.render(scene, camera);
                
                gl.colorMask(false, false, false, false);
                gl.depthMask(false);
                gl.enable(gl.STENCIL_TEST);
                gl.disable(gl.CULL_FACE);
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.INCR_WRAP);
                gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.DECR_WRAP);
                gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
                renderer.render(scene_vol, camera);
                
                
                //Lit
                object.material = material_diffuse_specular;
                ground.material = material_diffuse_specular;
                //sphere_mesh.material = material_diffuse_specular;
                moon_mesh.material = moon_mat_Shader;         
                //sphere_mesh_earth.material = material_diffuse_specular;
                sphere_mesh_earth.material = sphere_earth_Shader;         
                sun_mesh.material = material_diffuse_specular;
                
                
                gl.colorMask(true, true, true, true);
                gl.depthMask(true);
                gl.enable(gl.CULL_FACE);
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.depthFunc(gl.LEQUAL);
                gl.stencilFunc(gl.EQUAL, 0, 0xFF);
                renderer.render(scene, camera);
			}
		</script>  
	</body>
</html>